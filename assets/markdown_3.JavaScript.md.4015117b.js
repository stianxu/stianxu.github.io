import{_ as s,c as l,o as n,a}from"./app.3074115f.js";const A=JSON.parse('{"title":"JS","description":"","frontmatter":{},"headers":[{"level":2,"title":"ES6 新特性","slug":"es6-新特性","link":"#es6-新特性","children":[]},{"level":2,"title":"数据类型","slug":"数据类型","link":"#数据类型","children":[]},{"level":2,"title":"类数组","slug":"类数组","link":"#类数组","children":[]},{"level":2,"title":"字符串方法","slug":"字符串方法","link":"#字符串方法","children":[]},{"level":2,"title":"数组方法","slug":"数组方法","link":"#数组方法","children":[]},{"level":2,"title":"对象方法","slug":"对象方法","link":"#对象方法","children":[]},{"level":2,"title":"变量声明","slug":"变量声明","link":"#变量声明","children":[]},{"level":2,"title":"DOM 和 BOM","slug":"dom-和-bom","link":"#dom-和-bom","children":[]},{"level":2,"title":"DOM 操作","slug":"dom-操作","link":"#dom-操作","children":[]},{"level":2,"title":"DOM 事件流","slug":"dom-事件流","link":"#dom-事件流","children":[]},{"level":2,"title":"DOM 事件委托","slug":"dom-事件委托","link":"#dom-事件委托","children":[]},{"level":2,"title":"作用域、作用域链、闭包","slug":"作用域、作用域链、闭包","link":"#作用域、作用域链、闭包","children":[]},{"level":2,"title":"原型对象、原型链","slug":"原型对象、原型链","link":"#原型对象、原型链","children":[]},{"level":2,"title":"创建对象","slug":"创建对象","link":"#创建对象","children":[]},{"level":2,"title":"new","slug":"new","link":"#new","children":[]},{"level":2,"title":"继承","slug":"继承","link":"#继承","children":[]},{"level":2,"title":"this","slug":"this","link":"#this","children":[]},{"level":2,"title":"call()、apply()、bind()","slug":"call-、apply-、bind","link":"#call-、apply-、bind","children":[]},{"level":2,"title":"异步编程","slug":"异步编程","link":"#异步编程","children":[]},{"level":2,"title":"Promise","slug":"promise","link":"#promise","children":[]},{"level":2,"title":"async、await","slug":"async、await","link":"#async、await","children":[]},{"level":2,"title":"ajax、axios、fetch","slug":"ajax、axios、fetch","link":"#ajax、axios、fetch","children":[]},{"level":2,"title":"JSON","slug":"json","link":"#json","children":[]},{"level":2,"title":"...","slug":"","link":"#","children":[]},{"level":2,"title":"箭头函数","slug":"箭头函数","link":"#箭头函数","children":[]},{"level":2,"title":"解构赋值","slug":"解构赋值","link":"#解构赋值","children":[]},{"level":2,"title":"深浅拷贝","slug":"深浅拷贝","link":"#深浅拷贝","children":[]},{"level":2,"title":"模板字符串","slug":"模板字符串","link":"#模板字符串","children":[]},{"level":2,"title":"重绘和重排","slug":"重绘和重排","link":"#重绘和重排","children":[]},{"level":2,"title":"节流与防抖","slug":"节流与防抖","link":"#节流与防抖","children":[]}],"relativePath":"markdown/3.JavaScript.md"}'),p={name:"markdown/3.JavaScript.md"},o=a(`<h1 id="js" tabindex="-1">JS <a class="header-anchor" href="#js" aria-hidden="true">#</a></h1><h2 id="es6-新特性" tabindex="-1">ES6 新特性 <a class="header-anchor" href="#es6-新特性" aria-hidden="true">#</a></h2><ul><li><p>不一样的变量声明：const 和 let</p></li><li><p>模版字符串：反引号 + $</p></li><li><p>箭头函数：使用括号包裹参数，跟随一个 =&gt;，紧接着是函数体</p></li><li><p>函数的参数默认值：fn ( a = 1 )</p></li><li><p>Spread / Rest 操作符（...）：具体是 扩展还是 收敛 需要看上下文语境</p></li><li><p>对象和数组解构赋值</p></li><li><p>提供了定义类的语法糖（class）</p></li><li><p>Object.keys()、Array.from()、String.startsWith() 等新方法</p></li></ul><h2 id="数据类型" tabindex="-1">数据类型 <a class="header-anchor" href="#数据类型" aria-hidden="true">#</a></h2><p><strong>基本类型</strong></p><ul><li>string、number、boolean、null、undefined、symbol、bigInt。</li></ul><p><strong>引用类型</strong></p><ul><li>object 是个大类：function 函数、array 数组、date 日期等都归属于 object。</li></ul><p><strong>symbol 和 bigInt 是 ES6 中新增的数据类型</strong></p><ul><li><p>symbol 代表创建后独一无二且不可变的数据类型，为了解决可能出现的全局变量冲突的问题。</p></li><li><p>bigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 bigInt 可以安全地存储和操作大整数。</p></li></ul><p><strong>null 和 undefined 的区别</strong></p><ul><li>undefined 和 null 都是基本数据类型，分别都只有一个值，就是 undefined 和 null。</li><li>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。</li><li>变量声明了还没有定义的时候会返回 undefined，null 主要用于初始化赋值。</li><li>当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</li></ul><p><strong>内置对象</strong></p><ul><li>常用的 Date、Error、Promise、JSON 等，还有提供数学计算的 Math 对象。</li></ul><p><strong>数据传递</strong></p><ul><li><p>基本类型：值传递。</p></li><li><p>引用类型：传递的是地址，变量中存的就是地址。</p></li></ul><p><strong>数据类型隐式转换</strong></p><ul><li><p>在 if 语句、逻辑语句、数学运算逻辑、== 等情况下都可能出现隐式类型转换。</p><ul><li>比如 0、NaN、null、undefind、&quot; &quot; =&gt; false</li></ul></li><li><p>判断时, 尽量不要用 <code>= =</code> , 要用 <code>= = =</code></p><ul><li>两个等号判断, 如果类型不同, 默认会进行隐式类型转换再比较</li></ul></li></ul><p><strong>数据类型检测</strong></p><ul><li><p><strong>typeof</strong></p><ul><li>array、object、null 都会被判断为 object，其他判断都正确。</li></ul></li><li><p><strong>instanceof</strong></p><ul><li>只能正确判断引用数据类型，而不能正确判断基本数据类型。</li></ul></li><li><p><strong>Object.prototype.toString.call( )</strong></p><ul><li>能够正确判断所有数据类型。</li></ul></li></ul><p><strong>判断数组的方式</strong></p><ul><li><p>通过 Object.prototype.toString.call( ) 做判断</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#FFCB6B;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">toString</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#A6ACCD;">(arr) </span><span style="color:#89DDFF;">===</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">[object Array]</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p>通过 ES6 的 Array.isArray() 做判断</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">Array</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">isArray</span><span style="color:#A6ACCD;">(arr) </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><p><strong>判断空对象的方式</strong></p><ul><li><p>使用 JSON 自带的 stringify 方法来判断</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;">(Json</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">stringify</span><span style="color:#A6ACCD;">(Obj) </span><span style="color:#89DDFF;">==</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">{}</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> )</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">空对象</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p>使用 ES6 新增的方法 Object.keys( ) 来判断</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#A6ACCD;">(Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">keys</span><span style="color:#A6ACCD;">(Obj)</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">length </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">空对象</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><h2 id="类数组" tabindex="-1">类数组 <a class="header-anchor" href="#类数组" aria-hidden="true">#</a></h2><p><strong>类数组</strong></p><ul><li>一个拥有 <code>length</code> 属性和若干<code>索引</code>属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法，可以用 forEach 遍历。</li><li>常见的类数组对象有 arguments 和 DOM 方法的返回结果。</li></ul><p><strong>类数组转换为数组</strong></p><ul><li><p>使用 Array.from() 方法将类数组转化成数组</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">(){</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">arrArgs</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">Array</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">from</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">arguments</span><span style="color:#F07178;">) </span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">arrArgs</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forEach</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;font-style:italic;">a</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;">))</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p>使用 展开运算符 将类数组转化成数组</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">foo</span><span style="color:#89DDFF;">(){</span><span style="color:#F07178;"> </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">arrArgs</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> [</span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">arguments</span><span style="color:#F07178;">] </span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">arrArgs</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forEach</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;font-style:italic;">a</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;">)) </span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><h2 id="字符串方法" tabindex="-1">字符串方法 <a class="header-anchor" href="#字符串方法" aria-hidden="true">#</a></h2><p><strong>判定是否存在</strong></p><ul><li><p>includes：判断字符串与子串的包含关系</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> son </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">haha</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> father </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xixi haha hehe</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">father</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">includes</span><span style="color:#A6ACCD;">(son) </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p>startsWith：判断字符串是否以某个/某串字符开头</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> father </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xixi haha hehe</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">father</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">startsWith</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xixi</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p>endsWith：判断字符串是否以某个/某串字符结尾</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> father </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">xixi haha hehe</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#A6ACCD;">  father</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">endsWith</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">hehe</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// true</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><p><strong>自动重复</strong></p><ul><li><p>repeat：使同一个字符串被连续复制多次</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> sourceCode </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">repeat for 3 times;</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> repeated </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> sourceCode</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">repeat</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">) </span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(repeated) </span><span style="color:#676E95;font-style:italic;">// repeat for 3 times;repeat for 3 times;repeat for 3 times;</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><h2 id="数组方法" tabindex="-1">数组方法 <a class="header-anchor" href="#数组方法" aria-hidden="true">#</a></h2><p><strong>不改变原数组</strong></p><ul><li><p>join 转换成字符串</p></li><li><p>concat 数组合并</p></li><li><p>map 遍历迭代数组返回新数组</p></li><li><p>every 判断所有元素是不是都符合条件</p></li><li><p>some 判断是否有满足条件的元素</p></li><li><p>filter 筛选数组</p></li><li><p>forEach 遍历数组</p></li><li><p>reduce 累计器</p></li><li><p>find 查找第一个满足条件的元素</p></li><li><p>includes 判断数组中是否有某个元素</p></li></ul><p><strong>改变原数组</strong></p><ul><li><p>pop 删除数组最后一个元素</p></li><li><p>push 末尾添加元素</p></li><li><p>shift 删除数组第一个元素</p></li><li><p>unshift 头部添加元素</p></li><li><p>reverse 反转数组元素</p></li><li><p>sort 数组元素排序</p></li><li><p>splice 删除数组任意位置任意个数的元素</p></li><li><p>Array.from 伪数组转换为真数组</p></li></ul><p><strong>forEach 和 map 方法的区别</strong></p><ul><li>forEach() 方法单纯的遍历数组，无返回值。</li><li>map() 方法返回一个新数组，新数组中的值为原数组迭代处理之后的值。</li></ul><p><strong>for...in 和 for...of 的区别</strong></p><ul><li>for...in 遍历的是 key，可以用于 对象，数组，字符串，得到对象的<code>key</code>或数组、字符串的下标。</li><li>for...of 遍历的是 value，可以用于 数组，字符串，得到数组、字符串的值。</li></ul><h2 id="对象方法" tabindex="-1">对象方法 <a class="header-anchor" href="#对象方法" aria-hidden="true">#</a></h2><p><strong>Object.keys()</strong></p><ul><li><p>获取对象中所有属性名</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> o </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">佩奇</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">6</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 获得对象的所有键，并且返回是一个数组</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> arr </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">keys</span><span style="color:#A6ACCD;">(o)</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(arr) </span><span style="color:#676E95;font-style:italic;">// [&#39;name&#39;, &#39;age&#39;]</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><p><strong>Object.values()</strong></p><ul><li><p>获取对象中所有的属性值</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> o </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">佩奇</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">6</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 获取对象的所有值，并且返回是一个数组</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> arr </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">values</span><span style="color:#A6ACCD;">(o)</span></span>
<span class="line"><span style="color:#A6ACCD;">consolo</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(arr) </span><span style="color:#676E95;font-style:italic;">// [&#39;佩奇&#39;, 6]</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><p><strong>Object.assign()</strong></p><ul><li><p>常用于浅拷贝</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 拷贝对象 把 o 拷贝给 obj</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> o </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">佩奇</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">6</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#A6ACCD;">Object</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">assign</span><span style="color:#A6ACCD;">(obj</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> o)</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(obj) </span><span style="color:#676E95;font-style:italic;">// { name: &#39;佩奇&#39;, age: 6 }</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><h2 id="变量声明" tabindex="-1">变量声明 <a class="header-anchor" href="#变量声明" aria-hidden="true">#</a></h2><p><strong>变量初始赋值</strong></p><ul><li>在变量声明时，var 和 let 可以不用设置初始值。而 const 声明变量必须设置初始值。</li></ul><p><strong>重复声明赋值</strong></p><ul><li><p>var 声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。</p></li><li><p>const 和 let 不允许重复声明变量。</p></li><li><p>let、var 创建的变量可以重新赋值，const 声明的变量是不允许重新赋值。</p></li><li><p>const 保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。</p></li></ul><p><strong>变量提升</strong></p><ul><li>var 存在变量提升，在变量声明前访问不会报错。let 和 const 不存在变量提升，即变量只能在声明之后访问，否则会报错。</li><li>变量提升的表现是，在函数中任意位置声明的变量，JS 解析都将声名的代码提升到函数的首部，而赋值的代码保留在原地。</li></ul><p><strong>块级作用域</strong></p><ul><li>块作用域由 <code>{ }</code>包括，let 和 const 具有块级作用域，var 不存在块级作用域。</li></ul><p><strong>给全局添加属性</strong></p><ul><li>var 声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是 let 和 const 不会。</li></ul><h2 id="dom-和-bom" tabindex="-1">DOM 和 BOM <a class="header-anchor" href="#dom-和-bom" aria-hidden="true">#</a></h2><p><strong>DOM</strong></p><ul><li>文档对象模型，把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li><li>DOM 的核心 document 对象，是 BOM 的 window 对象的子对象。</li></ul><p><strong>BOM</strong></p><ul><li>浏览器对象模型，把浏览器当做一个对象，这个对象主要定义了与浏览器进行交互的方法和接口。</li><li>BOM 的核心 window 对象，含有 document 文档对象、location 地址对象、navigator 浏览器对象、screen 屏幕对象、history 历史对象等子对象。</li></ul><h2 id="dom-操作" tabindex="-1">DOM 操作 <a class="header-anchor" href="#dom-操作" aria-hidden="true">#</a></h2><p><strong>获取单个 DOM 元素</strong></p><ul><li>向 document.querySelector 中传入 css 选择器，即可选中单个 DOM 元素。</li><li>如果没有元素被获取到，返回 null。</li></ul><p><strong>获取 DOM 元素集合</strong></p><ul><li>向 document.querySelectorAll 中传入 css 选择器，即可选中多个元素的集合。</li><li>它会返回一个 类数组，如果没有元素被获取到，则会返回一个空的类数组。</li></ul><p><strong>创建 DOM 元素</strong></p><ul><li>document.createElement(tagName)</li></ul><p><strong>新增 DOM 元素</strong></p><ul><li>parentElement.appendChild(childElement)</li></ul><p><strong>修改 DOM 元素文案</strong></p><ul><li>Element.innerHTML：包含标签在内的所有内容</li><li>Element.innerText：包含标签内的文字内容，不包括标签</li></ul><p><strong>删除 DOM 元素</strong></p><ul><li>parentElement.removeChild(childElement)</li></ul><p><strong>DOM 事件监听</strong></p><ul><li><p>addEventListener()</p><ul><li>用于向指定元素添加监听事件，而且同一元素可以重复添加，不会覆盖之前的事件。</li></ul></li><li><p>removeEventListener()</p><ul><li>用于移除事件监听。</li></ul></li></ul><h2 id="dom-事件流" tabindex="-1"><strong>DOM 事件流</strong> <a class="header-anchor" href="#dom-事件流" aria-hidden="true">#</a></h2><p><strong>事件流</strong></p><ul><li><p>⼜称为事件传播，是⻚⾯中接收事件的顺序，其中包含 3 个阶段</p><ul><li><p>事件捕获阶段</p></li><li><p>处于⽬标阶段</p></li><li><p>事件冒泡阶段</p></li></ul></li></ul><p><strong>事件流的触发顺序</strong></p><ul><li><p>事件捕获阶段，为截获事件提供了机会</p></li><li><p>实际的⽬标元素接收到事件</p></li><li><p>事件冒泡阶段，可在这个阶段对事件做出响应</p></li></ul><p><strong>事件捕获</strong></p><ul><li><p>事件开始由较为不具体的节点接收后，然后开始逐级向下传播到最具体的元素上。</p></li><li><p>事件捕获的最大作用在于：事件在到达预定⽬标之前就可以捕获到它。</p></li></ul><p><strong>事件冒泡</strong></p><ul><li>事件开始由最具体的元素（⽂档中嵌套层次最深的那个节点）接收到后，开始逐级向上传播到较为不具体的节点。</li></ul><h2 id="dom-事件委托" tabindex="-1">DOM 事件委托 <a class="header-anchor" href="#dom-事件委托" aria-hidden="true">#</a></h2><p><strong>事件委托</strong></p><ul><li>事件委托，就是利用了事件冒泡的机制，在较上层位置的元素上添加一个事件监听函数，来管理该元素及其所有子集元素上的事件。</li></ul><p><strong>优点</strong></p><ul><li>在绑定大量事件的时候，可以选择事件委托，减少事件注册数量，节省内存占⽤。</li><li>当新增⼦元素时，⽆需再次做事件绑定，非常适合动态添加元素。</li></ul><h2 id="作用域、作用域链、闭包" tabindex="-1">作用域、作用域链、闭包 <a class="header-anchor" href="#作用域、作用域链、闭包" aria-hidden="true">#</a></h2><p><strong>作用域</strong></p><ul><li>作用域就是变量，函数能够使用的范围。</li></ul><p><strong>全局作用域</strong></p><ul><li>在代码的最外层的变量和函数称为全局作用域。</li><li>所有未定义直接赋值的变量自动声明为全局作用域。</li><li>window 对象的属性和方法，拥有全局作用域</li><li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li></ul><p><strong>局部作用域</strong></p><ul><li>局部作用域相当于函数作用域，指函数内部的空间。</li><li>每个函数都有自己的作用域，而且调用一次就会生成新的作用域，只能在函数内部才能访问。</li><li>作用域是分层的，内层作用域可以访问外层作用域，反之不行。</li></ul><p><strong>块级作用域</strong></p><ul><li>使用 ES6 中新增的 let 和 const 指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中创建。</li><li>块级作用域在 { } 包裹的代码片段内部起作用，一般用在 for 等循环语句中，可以避免变量外泄。</li></ul><p><strong>作用域链</strong></p><ul><li>在当前作用域找不到变量会依次向上级作用域查找，直到访问到 window 对象被终止，这一层一层的作用域嵌套关系就是作用域链，通过作用域链，可以访问到外层环境的变量。</li></ul><p><strong>闭包</strong></p><ul><li><p>有两个函数，内部函数定义在外部函数中，并且内部函数使用了外部函数环境中定义的变量，当内部函数执行的时候，外部函数就形成了一个闭包。</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 闭包最简单的形式</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">outer</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">var</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">function</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">inner</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">a</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">inner</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">outer</span><span style="color:#A6ACCD;">()</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><p><strong>闭包用途</strong></p><ul><li><p>保护：在实际的项目中，会基于闭包把自己编写的模块内容包裹起来，这样编写就可以保护自己的代码是私有的，防止和全局变量或者是其他的代码冲突，这一点是利用保护机制。</p></li><li><p>保存：在没有使用 ES6 的 let 之前，for 循环体中，需要利用闭包保存机制，使局部变量常驻内存，来实现我们的需求。只不过现在基于 let 会产生块级作用域来保护需要保存的内容。</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#676E95;font-style:italic;">// 打印 10个10</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> (</span><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++</span><span style="color:#A6ACCD;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 打印出10个10</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 闭包</span></span>
<span class="line"><span style="color:#89DDFF;font-style:italic;">for</span><span style="color:#A6ACCD;"> (</span><span style="color:#C792EA;">var</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i </span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">10</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> i</span><span style="color:#89DDFF;">++</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  (</span><span style="color:#C792EA;">function</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">i</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">setTimeout</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">()</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">      </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#89DDFF;">},</span><span style="color:#F07178;"> </span><span style="color:#F78C6C;">1000</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)(</span><span style="color:#A6ACCD;">i</span><span style="color:#F07178;">)</span><span style="color:#89DDFF;">;</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">// 打印出0-9</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p>不合理的使用闭包，从而导致某些变量一直被留在内存当中，会导致内存泄漏。</p></li></ul><h2 id="原型对象、原型链" tabindex="-1">原型对象、原型链 <a class="header-anchor" href="#原型对象、原型链" aria-hidden="true">#</a></h2><p><strong>原型对象</strong></p><ul><li><p>每一个构造函数的内部都有一个 prototype 属性，它的属性值指向原型对象，基于构造函数创建出来的实例对象，都可以共享访问原型对象的属性。</p></li><li><p>通过原型对象可以起到<code>共享属性</code>的作用，如果在一个对象上找不到某个属性，就会去它的原型对象上找，以此类推直至找到，寻找到原型链的终点都没找到则不存在。</p></li></ul><p><strong>原型链</strong></p><ul><li><p>每个对象中都有一个 <code>__proto__</code> 属性，这个属性指向了当前对象的构造函数的原型。</p></li><li><p>对象可以通过自身的 <code>__proto__</code>属性与它的构造函数的原型对象连接起来。</p></li><li><p>而因为它的原型对象也有 <code>__proto__</code>，因此这样就串联形成一个链式结构，也就是我们称为的原型链。</p></li><li><p>实例对象在查找属性时，如果查找不到，就会沿着<code>__proto__</code>去与对象关联的原型上查找，如果还查找不到，就去找原型的原型，直至查到最顶层 <code>null</code>。</p></li><li><p>平时创建对象明明没有创建对应的一些方法（如 <code>toString</code>、<code>valueOf</code> 等方法 ），却可以使用，是因为对象存在一条原型链。</p></li></ul><p><strong>构造函数、原型对象、实例对象的关系</strong></p><ul><li>每个构造函数都有一个显示原型 prototype</li><li>每个实例对象都有一个隐式原型 __proto__</li><li>实例对象的隐式原型 __proto__ 指向对应构造函数的显示原型 prototype</li></ul><h2 id="创建对象" tabindex="-1">创建对象 <a class="header-anchor" href="#创建对象" aria-hidden="true">#</a></h2><p><strong>一般使用字面量的形式直接创建对象</strong></p><ul><li>创建大量相似对象的时候，会产生大量的重复代码。</li></ul><p><strong>工厂模式</strong></p><ul><li>用函数封装创建对象的细节，通过调用函数来达到复用的目的。</li><li>只是简单的封装了复用代码，没有建立起对象和类型间的关系。</li></ul><p><strong>构造函数模式</strong></p><ul><li>执行构造函数的代码，为这个新对象添加属性或方法后返回这个新对象。</li><li>创建的对象和构造函数建立起了联系，可以通过原型来识别对象的类型，但是每次创建实例时，每个方法都要被创建一次。</li></ul><p><strong>原型模式</strong></p><ul><li>每个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。可以使用原型对象来添加公用属性和方法，从而实现代码的复用。</li><li>但是所有的属性和方法都会共享，并且无法初始化参数。</li></ul><p>**组合使用 构造函数模式 和 原型模式 **</p><ul><li>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</li></ul><h2 id="new" tabindex="-1">new <a class="header-anchor" href="#new" aria-hidden="true">#</a></h2><p><strong>new 操作符的执行过程</strong></p><ul><li><p>首先创建了一个新的空对象。</p></li><li><p>设置原型，将该对象的原型设置为构造函数的 prototype 对象。</p></li><li><p>让构造函数的 this 指向这个对象，执行构造函数的代码，为这个新对象添加属性或方法。</p></li><li><p>返回这个新对象。</p></li></ul><h2 id="继承" tabindex="-1">继承 <a class="header-anchor" href="#继承" aria-hidden="true">#</a></h2><p><strong>构造函数继承</strong></p><ul><li><p>在子类构造函数中用父类构造函数执行<code>.call(this)</code>，只能继承父类构造函数的实例属性和方法，不能继承父类构造函数原型上的属性和方法。</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Person</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">tom</span><span style="color:#89DDFF;">&#39;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Student</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">  </span><span style="color:#676E95;font-style:italic;">// 对象冒充继承</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">Person</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Student</span><span style="color:#A6ACCD;">()</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">name) </span><span style="color:#676E95;font-style:italic;">// tom</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><p><strong>原型链继承</strong></p><ul><li><p>继承父类构造函数原型身上的属性和方法</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Person</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#FFCB6B;">Person</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Student</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 原型链继承</span></span>
<span class="line"><span style="color:#FFCB6B;">Student</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">__proto__ </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Person</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#FFCB6B;">Student</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">a) </span><span style="color:#676E95;font-style:italic;">// 1</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><p><strong>组合方式继承</strong></p><ul><li><p>继承父类构造函数的实例属性和方法，同时继承父类构造函数原型上的属性和方法</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Person</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">this.</span><span style="color:#A6ACCD;">name</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">tom</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#FFCB6B;">Person</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">age </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">18</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// 混合方式继承</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">Student</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">Person</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">call</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">this</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#FFCB6B;">Student</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">__proto__ </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Person</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">prototype</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><p><strong>class 继承</strong></p><ul><li><p>组合方式继承的语法糖</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Person</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{}</span></span>
<span class="line"><span style="color:#C792EA;">class</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Student</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">extends</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Person</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">constructor</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">super</span><span style="color:#F07178;">()</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><h2 id="this" tabindex="-1">this <a class="header-anchor" href="#this" aria-hidden="true">#</a></h2><p><strong>this</strong></p><ul><li><code>this</code> 是一个在运行时才进行绑定的引用，在不同的情况下它可能会被绑定不同的对象。</li></ul><p><strong>默认绑定</strong></p><ul><li><strong>指向 window 的情况</strong>，默认情况下，this 会被绑定到全局对象 window 上。</li></ul><p><strong>隐式绑定</strong></p><ul><li><strong>谁调用，this 指向谁</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li></ul><p><strong>显示绑定</strong></p><ul><li><strong>想让 this 指向谁，this 就指向谁</strong>，通过 **apply 、 call 和 bind **这三个方法可以显示的改变函数体内 this 的指向。</li></ul><p><strong>new 绑定</strong></p><ul><li>当使用 <strong>new</strong> 调用构造函数时，会创建一个新的对象，this 指向这个新创建的对象。</li></ul><p><strong>优先级</strong></p><ul><li>new 绑定 &gt; 显示绑定 &gt; 隐式绑定 &gt; 默认绑定</li></ul><h2 id="call-、apply-、bind" tabindex="-1">call()、apply()、bind() <a class="header-anchor" href="#call-、apply-、bind" aria-hidden="true">#</a></h2><p><strong>相同点</strong></p><ul><li>都可以改变函数体内 this 的指向，第一个参数都是 this 要指向的对象。</li></ul><p><strong>不同点</strong></p><ul><li>call 方法接收的参数，第一个是 this 要指向的对象，其余参数逐个列举出来。</li><li>apply 方法接收两个参数，第一个是 this 要指向的对象，第二个是参数数组。</li><li>bind 方法接收参数与 call 一致，区别在于 bind 是返回对应函数，便于稍后调用，apply、call 则是立即调用 。</li></ul><p><strong>使用场景</strong></p><ul><li>call 经常用作<strong>继承</strong>，比如当前构造函数继承其他构造函数内部 this 上的属性。</li><li>apply 经常用于<strong>数组</strong>相关，比如借助于数学对象计算最大值最小值。</li><li>bind 经常用于不调用函数的情况下改变 this 指向，比如<strong>改变定时器内部的 this 指向</strong></li></ul><h2 id="异步编程" tabindex="-1"><strong>异步编程</strong> <a class="header-anchor" href="#异步编程" aria-hidden="true">#</a></h2><p><strong>异步编程的实现方式</strong></p><ul><li><p><strong>回调函数</strong></p><ul><li>使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，不利于代码的维护。</li></ul></li><li><p><strong>Promise</strong></p><ul><li>使用 Promise 的方式可以将嵌套的回调函数作为链式调用。</li><li>但是有时会造成多个 then 的链式调用，造成代码的语义不够明确。</li></ul></li><li><p><strong>async / await</strong></p><ul><li>可以将异步逻辑，转化为同步的顺序来书写，带来同步化代码的阅读书写体验。</li></ul></li></ul><h2 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-hidden="true">#</a></h2><p><strong>Promise</strong></p><ul><li>Promise 对象是异步编程的一种解决方案。</li><li>Promise 是一个构造函数，Promise 构造函数身上有 all、race 等静态方法，Promise 原型上有 then、catch 等方法。</li><li>一个 Promise 实例有三种状态，分别是 pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态一经改变，无法再次更改。</li></ul><p><strong>Promise 的使用</strong></p><ul><li><p>首先初始化一个 Promise 对象，new Promise() 传入一个函数作为参数。</p></li><li><p>new Promise() 传入的函数执行成功，调用 resolve 方法，在 then 方法执行成功后的回调。</p></li><li><p>new Promise() 传入的函数执行失败，调用 reject 方法，在 catch 方法执行失败后的回调。</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> promise </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">new</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Promise</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">resolve</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">reject</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">status</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#FF9CAC;">false</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;font-style:italic;">if</span><span style="color:#F07178;"> (</span><span style="color:#A6ACCD;">status</span><span style="color:#F07178;">) </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">resolve</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">操作成功!</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">else</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">reject</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">操作失败!</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">then</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">1</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> )</span></span>
<span class="line"><span style="color:#A6ACCD;">promise</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">catch</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">()</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">2</span><span style="color:#89DDFF;">&#39;</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><p><strong>Promise 构造函数静态方法</strong></p><ul><li><strong>Promise.all() 等待原则</strong><ul><li><code>all</code>方法可以完成并行任务，它接收一个数组，数组的每一项都是一个<code>promise</code>对象。</li><li>当数组中所有的<code>promise</code>对象的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。</li></ul></li><li><strong>Promise.race() 竞速原则</strong><ul><li><code>race</code>方法和<code>all</code>一样，它接收一个数组，数组的每一项都是一个<code>promise</code>对象。</li><li>与<code>all</code>不同的是，如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那<code>race</code>方法的状态变成了<code>resolved</code>；反之第一个<code>promise</code>对象变成<code>rejected</code>，那<code>race</code>方法的状态就会变成<code>rejected</code>。</li></ul></li></ul><h2 id="async、await" tabindex="-1">async、await <a class="header-anchor" href="#async、await" aria-hidden="true">#</a></h2><p><strong>async、await</strong></p><ul><li>async / await 基于 Promise，它是为优化 then 链而开发出来的。从字面上来看，async 是异步的含义，await 则为等待，所以很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成，await 必须用在 async 函数中。</li></ul><p><strong>async 关键字</strong></p><ul><li><p><code>async</code> 关键字用于声明⼀个异步函数。</p></li><li><p><code>async</code> 会⾃动将常规函数转换成 Promise，返回值也是⼀个 Promise 对象 。</p></li><li><p><code>async</code> 函数内部可以使⽤ <code>await</code> 。</p></li></ul><p><strong>await 关键字</strong></p><ul><li><code>await</code> 用于等待异步的功能执⾏完毕。</li><li><code>await</code> 后面的函数运行完并且有了返回结果之后，才继续执行下面的代码。</li><li><code>await</code> 必须用在 async 函数中。</li></ul><p><strong>async、await 对比 Promise 的优势</strong></p><ul><li>同步化代码的阅读体验，Promise 虽然摆脱了回调地狱，但是 then 的链式调⽤也会带来额外的阅读负担。</li><li>和同步代码更一致的错误处理方式，async/await 可以⽤成熟的 try/catch，比 Promise 的错误捕获更简洁直观。</li></ul><h2 id="ajax、axios、fetch" tabindex="-1">ajax、axios、fetch <a class="header-anchor" href="#ajax、axios、fetch" aria-hidden="true">#</a></h2><p><strong>ajax</strong></p><ul><li>ajax 的核心应用了 XMLHttpRequest 对象，通过这个对象，就可以实现在不重载页面的情况与 Web 服务器交换数据，即在不需要刷新页面的情况下，就可以产生局部刷新的效果。</li></ul><p><strong>fetch</strong></p><ul><li>fetch 号称是 ajax 的替代品，是在 ES6 出现的，使用了 ES6 中的 promise 对象。Fetch 是基于 promise 设计的。</li><li>Fetch 的代码结构比起 ajax 简单，fetch 不是对 ajax 的进一步封装，而是原生 js，没有使用 XMLHttpRequest 对象。</li></ul><p><strong>axios</strong></p><ul><li>axios 是一个第三方提供的方法，它与 ajax 一样，都是对 XMLHttpRequest 对象进行封装，并加入了 Promise 方法解决了回调地狱的问题，提供了可使用的大量的 API。</li><li>axios 是基于 Promise 封装的，支持 node 端和浏览器端，axios 会自动转换 JSON 数据，可以通过配置 axios 拦截器，对数据交互进行更好的处理。</li></ul><h2 id="json" tabindex="-1">JSON <a class="header-anchor" href="#json" aria-hidden="true">#</a></h2><p><strong>JSON 理解</strong></p><ul><li><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p></li><li><p>在项目开发中，使用 JSON 作为前后端数据交换的方式。</p><ul><li><p>前端通过将一个符合 JSON 格式的数据结构序列化为 JSON 字符串，然后将它传递到后端。</p></li><li><p>后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p></li></ul></li><li><p>JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，大多数的 JS 对象是不符合 JSON 对象的格式的。</p></li></ul><p><strong>JSON 格式的转换处理</strong></p><ul><li><p>在 JS 中提供了两个函数来实现 JS 数据结构和 JSON 格式的转换处理。</p><ul><li><p>JSON.stringify() 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</p></li><li><p>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 JS 数据结构，当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 JS 数据结构，以此来进行数据的访问。</p></li></ul></li></ul><h2 id="" tabindex="-1">... <a class="header-anchor" href="#" aria-hidden="true">#</a></h2><p><strong>rest 收集运算符</strong> 或 <strong>spread 扩展运算符</strong></p><ul><li>ES6 引入了一个新的运算符 <strong>...</strong>，通常称为 <strong>rest 收集运算符</strong> 或 <strong>spread 扩展运算符</strong>，取决于如何使用它。</li></ul><p><strong>rest 收集运算符</strong></p><ul><li><p>用于函数参数中，可以获取剩余实参列表，rest 参数必须要放在形参的最后。</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">get</span><span style="color:#89DDFF;">(...</span><span style="color:#A6ACCD;font-style:italic;">args</span><span style="color:#89DDFF;">){</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//1. arguments</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">arguments</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">//2. rest 参数</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">args</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">get</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><p><strong>spread 扩展运算符</strong></p><ul><li><p>用于数组之前，把数组展开为各个独立的值，可以将伪数组转为真正的数组。</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">[</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">]) </span><span style="color:#676E95;font-style:italic;">// 1 2 3</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> divs </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> document</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">querySelectorAll</span><span style="color:#A6ACCD;">(</span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">div</span><span style="color:#89DDFF;">&#39;</span><span style="color:#A6ACCD;">)</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> divArr </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> [</span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">divs]</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(divArr)</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p>用于对象之前，取出对象中的所有可遍历属性，方便对象拷贝或合并操作。</p><ul><li><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">a</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">b</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> obj1 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{...</span><span style="color:#A6ACCD;">obj</span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(obj1)</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">// {a: 1, b: 2}</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><p><strong>arguments 与 rest 运算符的区别</strong></p><ul><li>通过 arguments 获取到的实参集合是一个类数组。</li><li>通过 rest 参数获取到的实参集合是一个真数组。</li></ul><h2 id="箭头函数" tabindex="-1">箭头函数 <a class="header-anchor" href="#箭头函数" aria-hidden="true">#</a></h2><p><strong>箭头函数比普通函数更加简洁</strong></p><ul><li>如果没有参数，就直接写一个空括号即可</li><li>如果只有一个参数，可以省去参数的括号</li><li>如果有多个参数，用逗号分割</li><li>如果函数体的返回值只有一句，可以省略大括号</li></ul><p><strong>箭头函数没有自己的 this</strong></p><ul><li>箭头函数没有自己的 this，它只会在自己作用域的上一层继承 this。所以箭头函数中 this 的指向在它在定义时已经确定了，之后不会改变。</li></ul><p><strong>箭头函数没有 arguments</strong></p><ul><li>箭头函数没有 arguments 对象。可以使用 ... 剩余参数来获取。</li></ul><h2 id="解构赋值" tabindex="-1">解构赋值 <a class="header-anchor" href="#解构赋值" aria-hidden="true">#</a></h2><p><strong>数组的解构</strong></p><ul><li><p>在解构数组时，以元素的位置为匹配条件来提取想要的数据的</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> b</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> c</span><span style="color:#89DDFF;">]</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> [</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">3</span><span style="color:#A6ACCD;">]</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><p><strong>对象的解构</strong></p><ul><li><p>对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> stu </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">Bob</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">24</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> name</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> age </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> stu</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p>注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">const</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> age</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> name </span><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> stu</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><h2 id="深浅拷贝" tabindex="-1">深浅拷贝 <a class="header-anchor" href="#深浅拷贝" aria-hidden="true">#</a></h2><p><strong>引用类型，进行赋值时，赋值的是地址</strong></p><ul><li><p>浅拷贝</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">zs</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">18</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> obj2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">...</span><span style="color:#A6ACCD;">obj</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p>深拷贝</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> obj </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F07178;">name</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">zs</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">	</span><span style="color:#F07178;">age</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">18</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#F07178;">car</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#F07178;">brand</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&#39;</span><span style="color:#C3E88D;">宝马</span><span style="color:#89DDFF;">&#39;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">        </span><span style="color:#F07178;">price</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">100</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> obj2 </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> JSON</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">parse</span><span style="color:#A6ACCD;">(JSON</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">stringify</span><span style="color:#A6ACCD;">(obj))</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(obj2)</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p>递归</p></li></ul><h2 id="模板字符串" tabindex="-1">模板字符串 <a class="header-anchor" href="#模板字符串" aria-hidden="true">#</a></h2><p><strong>模版字符串</strong></p><ul><li><p>模版语法允许用 <code>\${}</code> 的方式嵌入变量，并且支持<code>运算</code>式的表达式，可以在<code>\${}</code>里完成一些计算。</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">add</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">a</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#A6ACCD;font-style:italic;">b</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">finalString</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">\`\${</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;"> + </span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">b</span><span style="color:#89DDFF;">}</span><span style="color:#C3E88D;"> = </span><span style="color:#89DDFF;">\${</span><span style="color:#A6ACCD;">a</span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;">b</span><span style="color:#89DDFF;">}\`</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">finalString</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#82AAFF;">add</span><span style="color:#A6ACCD;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">2</span><span style="color:#A6ACCD;">) </span><span style="color:#676E95;font-style:italic;">// 输出 &#39;1 + 2 = 3&#39;</span></span>
<span class="line"></span></code></pre></div></li></ul></li><li><p>模版字符串允许用 \`\` 的方式拼接字符串，在模板字符串中，空格、缩进、换行都会被保留。</p><ul><li><div class="language-javascript"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki material-theme-palenight" tabindex="0"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> list </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">\`</span></span>
<span class="line"><span style="color:#C3E88D;">	&lt;ul&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">		&lt;li&gt;列表项1&lt;/li&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">		&lt;li&gt;列表项2&lt;/li&gt;</span></span>
<span class="line"><span style="color:#C3E88D;">	&lt;/ul&gt;</span></span>
<span class="line"><span style="color:#89DDFF;">\`</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#A6ACCD;">(message)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">// 正确输出，不存在报错</span></span>
<span class="line"></span></code></pre></div></li></ul></li></ul><h2 id="重绘和重排" tabindex="-1">重绘和重排 <a class="header-anchor" href="#重绘和重排" aria-hidden="true">#</a></h2><p><strong>重绘</strong></p><ul><li><p>重绘是由于节点的⼏何属性发⽣改变，或由于样式发⽣改变，例如：改变元素背景⾊。</p></li><li><p>表现为某些元素的外观被改变。或者重排后，进行重新绘制。</p></li></ul><p><strong>重排</strong></p><ul><li>重排是指部分或整个渲染树需要重新分析，并且节点的尺⼨需要重新计算。例如：元素增删，尺寸位置改变。</li><li>表现为重新⽣成布局，重新排列元素。</li><li>重绘不⼀定会出现重排，重排必定会触发重绘。</li><li>每个页面初始化渲染至少需要一次 回流 + 重绘。</li></ul><p><strong>重绘重排优化</strong></p><ul><li>重排和重绘的代价都很⾼昂，频繁重排重绘，会破坏⽤户体验、让界面显示变迟缓。</li><li>我们需要尽可能避免频繁触发重排和重绘，尤其是重排。 <ul><li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li><li>集中修改样式，尽可能利用浏览器的优化机制，一次重排重绘就完成渲染。</li><li>利用 transform 实现动画视觉变化效果, 去代替 left top 的变换，只触发了自己的重绘，不会影响到其他盒子。</li><li>使用 absolute 或者 fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素。</li><li>将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在 display 属性为 none 的元素上进行的 DOM 操作不会引发回流和重绘。</li></ul></li></ul><ul><li><p>浏览器会对重绘重排进行优化。</p><ul><li><p>浏览器会维护 1 个队列，把所有会引起重排、重绘的操作放入这个队列。</p><ul><li><p>等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会进行一个<code>批处理</code>。</p></li><li><p>这样就会让多次的重排、重绘变成了一次重排重绘。</p></li></ul></li></ul></li></ul><h2 id="节流与防抖" tabindex="-1">节流与防抖 <a class="header-anchor" href="#节流与防抖" aria-hidden="true">#</a></h2><p><strong>节流和防抖</strong></p><ul><li>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</li><li>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</li></ul><p><strong>防抖函数的应用场景</strong></p><ul><li>按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次。</li><li>服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，类似搜索联想词功能。</li></ul><p><strong>节流函数的适⽤场景</strong></p><ul><li>拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动。</li><li>滚动加载，懒加载时要监听计算滚动条的位置，不必每次滑动都触发，可以降低计算的频率。</li></ul>`,233),e=[o];function t(c,r,i,y,D,F){return n(),l("div",null,e)}const d=s(p,[["render",t]]);export{A as __pageData,d as default};
